open System

let sampleInput = "ULL
RRDDD
LURDL
UUUUD"

let puzzleInput = "LRULLRLDUUUDUDDDRLUDRDLDDLUUDLDDLRDRLDRLLURRULURLDRLDUDURLURRULLDDDUDDRRRDLRRDDLDURDULLRDLLLDRDLLDULDUDLLDLDRUDLLDLDDRRRDRLUDRDDLUDRRDUDUDLLDDUUDLRDUDRRUDUDRULRULUDRUUDLDLULLRLDLDDRULLRLLLULUULDURURLUUULDURLDDDURRUUDURDDDULDLURLRDRURDRUDRLLDLDRUURLLLRDRURUDLRLUDULLDDURLRURDLRDUUURRLULRRLDDULUUURLRRRLLLLLURDDRUULUDRRRUDDLLULRRUULDRDDULRLDDDRRUULUDRLRUDURUUULDLDULUUDURLLLRRDDRDLURDDDLDDDLRDRLDDURLRLLRUDRRLLDDDDDURDURRDDULDULLRULDRUURDRRDUDDUDDDDRRDULDUURDRUDRLDULRULURLLRRDRDRDLUUDRRLRLDULDDLUUUUUURRLRRRULLDDDRLRDRRRRRRRDUUDLLUDURUDDLURRUDL
UDUUURRLRLLDDRRDRRRLDDDLURURLLUDDRLUUDRRRDURRLLRURDLLRRDUUDDDDRDRURRLLLLURDLRRRULLLDLLLUDDLDRRRDLDUUDDRDUDDUURDDLULULDURDURDRUULURURRURDUURUDRRUDRLLLLRRDLLDRDDRLLURDDDUDUDUDRUURDDRUURDLRUUDDRDUURUDDLLUURDLUDRUUDRRDLLUUURDULUULDUUDLLULUUDLUDRUUDUUURLDDDRLRURDDULLRDRULULUDLUUDDDUUDLDUUDRULLDUURDDRUDURULDRDDLRUULRRRDLDLRDULRDDRLLRRLURDLDRUDLRLUDLRLDLDURRUULRLUURDULDRRULLRULRDLLDLDUDRUDDUDLDDURDDDRDLUDRULRUULLRURLDDDRDLRRDRULURULDULRDLDULDURDRDRDRDURDRLUURLRDDLDDRLDDRURLLLURURDULDUDDLLUURDUUUDRUDDRDLDRLRLDURRULDULUUDDLRULDLRRRRDLLDRUUDRLLDLUDUULRDRDLRUUDLRRDDLUULDUULRUDRURLDDDURLRRULURR
LDURLLLRLLLUURLLULDLRLLDLURULRULRDUDLDDUDRLRRDLULLDDULUUULDRLDURURLURLDLRUDULLLULDUURLLRDLUULRULLLULRDRULUDLUUULDDURLUDDUDDRDLDRDRUDLUURDDLULDUULURLUULRDRDLURUDRUDLDRLUUUUULUDUDRRURUDRULDLDRDRLRURUUDRDLULLUDLLRUUDUUDUDLLRRRLDUDDDRDUDLDLLULRDURULLLUDLLRUDDUUDRLDUULLDLUUDUULURURLLULDUULLDLUDUURLURDLUULRRLLRUDRDLLLRRRLDDLUULUURLLDRDLUUULLDUDLLLLURDULLRUDUUULLDLRLDRLLULDUDUDRULLRRLULURUURLRLURRLRRRDDRLUDULURUDRRDLUDDRRDRUDRUDLDDRLRDRRLDDRLLDDDULDLRLDURRRRRULRULLUUULUUUDRRDRDRLLURRRRUULUDDUDDDLDURDRLDLLLLLRDUDLRDRUULU
URURRUUULLLLUURDULULLDLLULRUURRDRRLUULRDDRUDRRDUURDUDRUDDRUULURULDRLDRDDDLDLRLUDDRURULRLRLLLDLRRUDLLLLRLULDLUUDUUDRDLRRULLRDRLRLUUDDRRLLDDRULLLRLLURDLRRRRRLLDDRRDLDULDULLDLULLURURRLULRLRLLLLURDDRDDDUUDRRRDUUDDLRDLDRRLLRURUDUUUDLDUULLLRLURULRULRDRLLLDLDLRDRDLLLRUURDDUDDLULRULDLRULUURLLLRRLLLLLLRUURRLULRUUUDLDUDLLRRDDRUUUURRRDRRDULRDUUDULRRRDUUUUURRDUURRRRLDUDDRURULDDURDDRDLLLRDDURUDLLRURLRRRUDDLULULDUULURLUULRDLRDUDDRUULLLRURLDLRRLUDLULDRLUDDDRURUULLDLRLLLDULUDDRLRULURLRDRRDDLDLURUDDUUURRDDLUDDRDUULRRDLDRLLLULLRULRURULRLULULRDUD
RUDLLUDRRDRRLRURRULRLRDUDLRRLRDDUDRDLRRLLRURRDDLRLLRRURULRUULDUDUULDULDLRLRDLRDLRUURLDRLUDRRDDDRDRRRDDLLLRRLULLRRDDUDULRDRDUURLDLRULULUDLLDRUDUURRUDLLRDRLRRUUUDLDUDRRULLDURRDUDDLRURDLDRLULDDURRLULLRDDDRLURLULDLRUDLURDURRUDULDUUDLLLDDDUUURRRDLLDURRDLULRULULLRDURULLURDRLLRUUDDRRUDRDRRRURUUDLDDRLDRURULDDLLULULURDLDLDULLRLRDLLUUDDUDUDDDDRURLUDUDDDRRUDDLUDULLRDLDLURDDUURDLRLUUDRRULLRDLDDDLDULDUDRDUUULULDULUDLULRLRUULLDURLDULDRDLLDULLLULRLRD"

let instructionLines (text: string) = List.ofArray (text.Split([| "\r\n" |], StringSplitOptions.None))

type Direction = Up | Right | Down | Left

type Keypad = One | Two | Three | Four | Five | Six | Seven | Eight | Nine | A | B | C | D

let parseDirection character =
  match character with
  | 'L' -> Left
  | 'R' -> Right
  | 'U' -> Up
  | 'D' -> Down
  | _ -> failwith (sprintf "Illegal direction %A" character)

let charactersToDirections characters =
  List.map parseDirection characters 

let allInstructions text =
  instructionLines text
    |> List.map (fun s -> s.ToCharArray() |> List.ofArray |> (List.map parseDirection))

let nextButton =
  function
  | (One, Up) | (One, Left) | (One, Right) | (Three, Up) -> One
  | (Two, Left) | (Three, Left) | (Two, Up) | (Six, Up) -> Two
  | (Two, Right) | (One, Down) | (Four, Left) | (Seven, Up) -> Three
  | (Four, Up) | (Four, Right) | (Eight, Up) | (Three, Right) -> Four
  | (Six, Left) | (Five, Left) | (Five, Down) | (Five, Up) -> Five
  | (Seven, Left) | (Five, Right) | (Two, Down) | (A, Up) -> Six
  | (B, Up) | (Eight, Left) | (Three, Down) | (Six, Right) -> Seven
  | (Four, Down) | (Seven, Right) | (Nine, Left) | (C, Up) -> Eight
  | (Nine, Right) | (Nine, Down) | (Nine, Up) | (Eight, Right) -> Nine
  | (A, Left) | (A, Down) | (Six, Down) | (B, Left) -> A
  | (A, Right) | (C, Left) | (D, Up) | (Seven, Down) -> B
  | (C, Right) | (C, Down) | (Eight, Down) | (B, Right) -> C
  | (B, Down) | (D, Left) | (D, Right) | (D, Down) -> D

let visitedButtons startPoint directions =
  let rec visitedButtonsHelper directions startPoint =
    match (directions, startPoint) with
    | ([], _) -> []
    | (direction::ds, startPoint) -> 
      let next = nextButton (startPoint, direction)
      next::(visitedButtonsHelper ds next)
  visitedButtonsHelper directions startPoint

let last list = List.head (List.rev list)

let code instructions =
  let rec codeHelper instructions visitedSoFar code =
    match (instructions, visitedSoFar, code) with
    | ([], _, _) ->  (List.rev visitedSoFar, List.rev code)
    | (x::xs, [], []) ->
      let buttons = visitedButtons Five x
      codeHelper xs [buttons] [(last buttons)]
    | (x::xs, visited, code) ->
      let buttons = visitedButtons (List.head code) x
      codeHelper xs (buttons::visited) ((last buttons)::code)
  codeHelper instructions [] []

let printKey =
  function
  | One -> '1' | Two -> '2' | Three -> '3'
  | Four -> '4' | Five -> '5' | Six -> '6'
  | Seven -> '7' | Eight -> '8' | Nine -> '9'
  | A -> 'A' | B -> 'B' | C -> 'C' | D -> 'D'

[<EntryPoint>]
let main argv = 
    let sampleInstructions = allInstructions sampleInput
    let puzzleInstructions = allInstructions puzzleInput
    printfn "%A" (snd (code sampleInstructions))
    printfn "%A" (snd (code puzzleInstructions))
    printfn "%A" (new String(Array.ofList (List.map (printKey) (snd (code puzzleInstructions)))))
    0
